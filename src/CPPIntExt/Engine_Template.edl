-- File:	Engine_Template.edl
-- Author:	Kernel
-- History:	Thu Dec 21 16:50:43 1995	Kernel	Creation
-- Copyright:	 Matra Datavision 1995

--  =====================================================
--  Headers for Engines (Engine.cxx and Engine_Init_.cxx)
--  =====================================================

@template EngineCxxHeader(%NbInterf,%EngineName) is
$//
$//                     Copyright (C) 1991 - 2000 by  
$//                      Matra Datavision SA.  All rights reserved.
$//  
$//                     Copyright (C) 2001 - 2004 by
$//                     Open CASCADE SA.  All rights reserved.
$// 
$// This file is part of the Open CASCADE Technology software.
$//
$// This software may be distributed and/or modified under the terms and
$// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
$// and appearing in the file LICENSE included in the packaging of this file.
$//  
$// This software is distributed on an "AS IS" basis, without warranty of any
$// kind, and Open CASCADE SA hereby disclaims all such warranties,
$// including without limitation, any warranties of merchantability, fitness
$// for a particular purpose or non-infringement. Please see the License for
$// the specific terms and conditions governing rights and limitations under the
$// License.
$   
$#include <Engine.hxx>               
$#include <Engine_EnginePlugin.hxx>               
$#include <Engine_ExecutionError.hxx>
$#include <Engine_Signature.hxx>
$
$Handle_Standard_Type&  Engine_Handle_Type_(){
$
$ 
$static Handle_Standard_Transient _Ancestors[]= {
$ 
$NULL};
$
$static Handle_Standard_Type _aType = 
$       new Standard_Type("Engine_Handle",
$	                  sizeof(Engine_Handle),
$                         0,
$                         (Standard_Address)_Ancestors,
$                         (Standard_Address)NULL);
$return _aType;
$}
$
$void Engine_EnginePlugin::LoadMethods() {}
$
$extern "C" Standard_EXPORT void %EngineName_CallLoadMethod(Engine_EnginePlugin& anEngP)
${
$  
$  anEngP.CreatePArrayOfInterfacePlugin(%NbInterf) ;
@end;

@template EngineInitHeader() is
$//
$//                     Copyright (C) 1991 - 2000 by  
$//                      Matra Datavision SA.  All rights reserved.
$//  
$//                     Copyright (C) 2001 - 2004 by
$//                     Open CASCADE SA.  All rights reserved.
$// 
$// This file is part of the Open CASCADE Technology software.
$//
$// This software may be distributed and/or modified under the terms and
$// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
$// and appearing in the file LICENSE included in the packaging of this file.
$//  
$// This software is distributed on an "AS IS" basis, without warranty of any
$// kind, and Open CASCADE SA hereby disclaims all such warranties,
$// including without limitation, any warranties of merchantability, fitness
$// for a particular purpose or non-infringement. Please see the License for
$// the specific terms and conditions governing rights and limitations under the
$// License.
$
$#include <signal.h>
$#include <Standard_Stream.hxx>
$#include <Engine.hxx>
$#include <Engine_Signature.hxx>
$#include <Engine_Argument.hxx>
$#include <Engine_SequenceOfArgument.hxx>
$#include <Engine_PSequenceOfArgument.hxx>
$#include <Engine_AVLSearchTreeOfSignature.hxx>
$#define CSF1
$#define LENGTH 255
$int K_VERBOSE_INIT;
$// ------------------
@end;

--  ==================
--  Engine.cxx Loading
--  ==================

@template EngineCxxLoadMet(%NumInt,%IntName) is
$  anEngP.LoadMethods(%NumInt,"%IntName");
@end;


@template EngineCxxContExec() is
$
$}
$
$void Engine::Execute  (const Engine_Signature& aSignature,                 
$		       const Standard_Address  theObject)                  
${                                                                          
$  Standard_SStream Err;                                                    
$  char* ErrMsg="Error: We have found an interface but we can't execute it:"; 
$                                                                           
$  switch(aSignature.InterfaceId()) {                                       
$
@end;

@template EngineCxxCase(%NumInt,%IntName) is
$       case %NumInt : {                                 
$         void %IntName_Execute(const Engine_Signature&,    
$				     const Standard_Address);    
$         %IntName_Execute(aSignature,theObject);           
$         break;                                                  
$       }                                                      
$
@end;

--  =====================
--  Engine.ll Definitions
--  =====================

@template EngineLLDefClass(%CLName) is
$(generic-call %CLName classmethod-generic-call)
@end;

@template EngineLLDefPackage(%PKName) is
$(generic-call %PKName packagemethod-generic-call)
@end;

@template EngineLLSetEnum(%EnumMember,%EnumValue) is
$(setq %EnumMember %EnumValue)
@end;

--  =============================
--  Engine_Init types definitions
--  =============================

@template EngineInitDefType(%CLName,%InhDeclar,%InhList,%NbInh) is
$
@end;

@template EngineInitDeclInhType(%InhName,%NumInh) is
$
@end;

@template EngineInitEnumType(%CLName) is
$
@end;

@template EngineInitGlobType(%CLName) is
$
@end;


-- ====================
-- Engine_Init Function
-- ====================

@template EngineInitFunction() is
$
$void Engine_Init_(Engine_AVLSearchTreeOfSignature& anAVLTree,
$                  const Standard_Integer InterfaceId,
$                  const Standard_CString InterfaceName){
$ 
@end;

@template EngineInitTypeCall(%CLName) is
$
@end;


@template EngineInitBody() is
$
$  char *Get_Engine_Path(void) ;
$ 
$  char  MethodName[LENGTH];
$  char  ModuleName[LENGTH];
$  char  Buff      [LENGTH];
$  char  Category  [LENGTH];
$  char  TypeArg   [LENGTH];
$  Engine_MethodCategory TheCategory       ;
$  Engine_ModeType       TheMode           ;
$  int   j                 ;
$  int   NbArg             ;
$  int   MethodId = 1      ;
$  Engine_PSequenceOfArgument Args;
$  char  *FileName;
$
$  //char EnginePath[257]    ;
$  char *EnginePath;
$  //struct STATUS sts;
$
$ 
$  EnginePath = Get_Engine_Path();
$  if (EnginePath[0] != '/') {	
$      cerr << "error: Unable to find the engine path" << endl;
$  }
$ 
$  FileName = new char [ strlen ( EnginePath ) 
$                        + strlen ( InterfaceName ) + 1 
$                        + strlen ("_ExportedMethods.dat") + 1  ];
$  strcpy (FileName,EnginePath);
$  strcat (FileName,"-");
$  strcat (FileName,InterfaceName);
$  strcat (FileName,"_ExportedMethods.dat");
$  ifstream file ( FileName );
$  cout << "\rFileName = " << FileName << "\r" << endl;
$  while ( file.getline(MethodName,(int)sizeof(Buff) ) ){
$    file.getline(ModuleName,(int)sizeof(Buff));
$    file.getline(Category  ,(int)sizeof(Buff));
$    TheCategory = (Engine_MethodCategory) atoi (Category);
$    file.getline(Buff    ,(int)sizeof(Buff));
$    NbArg = atoi ( Buff );
$    Args = new Engine_SequenceOfArgument;
$    for ( j = 1; j <= NbArg; j++){
$      file.getline(TypeArg,(int)sizeof(Buff));
$      file.getline(Buff   ,(int)sizeof(Buff));
$      TheMode = (Engine_ModeType) atoi ( Buff );
$      Args->Append(Engine_Argument(TypeArg,TheMode));
$    }
$    file.getline(Buff    ,(int)sizeof(Buff));
$    NbArg = atoi ( Buff );
$    if(NbArg){
$      file.getline(TypeArg,(int)sizeof(Buff));
$      anAVLTree.Insert (Engine_Signature(
$					 MethodName,
$					 ModuleName,
$					 TheCategory,
$					 Args,
$					 Engine_Argument (TypeArg),
$					 MethodId++,
$					 InterfaceId
$					 ));
$    }
$    else {
$      anAVLTree.Insert (Engine_Signature(
$					 MethodName,
$					 ModuleName,
$					 TheCategory,
$					 Args,
$					 Engine_Argument (),
$					 MethodId++,
$					 InterfaceId
$					 ));
$    }
$  }	
$  delete [] FileName;
$
$
$}
@end;

-- =================
-- Engine.cxx Bottom
-- =================

@template EngineCxxBottom() is 
$  
$}   
$                                                                       
@end;
