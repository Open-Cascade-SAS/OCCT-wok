-- File:	CSFDBSchema_Template.edl
-- Author:	Kernel
-- History:	Tue Apr  9 15:59:24 1996	Kernel	Creation
-- Copyright:	 Matra Datavision 1996

-- SCHEMA
--
@template CSFDBSchemaClassProto(%Schema) is
$// File generated by Schema (Schema)
$//
$//                     Copyright (C) 1991 - 2000 by  
$//                      Matra Datavision SA.  All rights reserved.
$//  
$// This file is part of the Open CASCADE Technology software.
$//
$// This software may be distributed and/or modified under the terms and
$// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
$// and appearing in the file LICENSE included in the packaging of this file.
$//  
$// This software is distributed on an "AS IS" basis, without warranty of any
$// kind, and Open CASCADE SA hereby disclaims all such warranties,
$// including without limitation, any warranties of merchantability, fitness
$// for a particular purpose or non-infringement. Please see the License for
$// the specific terms and conditions governing rights and limitations under the
$// License.
$
$#ifndef _%Schema_HeaderFile
$#define _%Schema_HeaderFile
$
$#ifndef _Standard_Macro_HeaderFile
$#include <Standard_Macro.hxx>
$#endif
$#ifndef _Storage_Macros_HeaderFile
$#include <Storage_Macros.hxx>
$#endif
$#ifndef _Storage_stCONSTclCOM_HeaderFile
$#include <Storage_stCONSTclCOM.hxx>
$#endif
$#ifndef _Handle_Storage_Schema_HeaderFile
$#include <Handle_Storage_Schema.hxx>
$#endif
$
$class Handle_Standard_Type;
$Standard_EXPORT Handle_Standard_Type& %Schema_Type_();
$class Standard_Transient;
$class Handle(Storage_Schema);
$class %Schema;
$
$class Handle(%Schema) : public Handle(Storage_Schema) {
$  public:
$    Handle(%Schema)():Handle(Storage_Schema)() {} 
$    Handle(%Schema)(const Handle(%Schema)& aHandle) : Handle(Storage_Schema)(aHandle) 
$     {
$     }
$
$    Handle(%Schema)(const %Schema* anItem) : Handle(Storage_Schema)((Storage_Schema *)anItem) 
$     {
$     }
$
$    Handle(%Schema)& operator=(const Handle(%Schema)& aHandle)
$     {
$      Assign(aHandle.Access());
$      return *this;
$     }
$
$    Handle(%Schema)& operator=(const %Schema* anItem)
$     {
$      Assign((Standard_Transient *)anItem);
$      return *this;
$     }
$
$    %Schema* operator->() 
$     {
$      return (%Schema *)ControlAccess();
$     }
$
$    %Schema* operator->() const 
$     {
$      return (%Schema *)ControlAccess();
$     }
$
$   ~Handle(%Schema)(){};
$
$   static const Handle(%Schema) DownCast(const Handle(Storage_Schema)& AnObject) 
$   {
$     Handle(%Schema) _anOtherObject;
$
$     if (!AnObject.IsNull()) {
$        if (AnObject->IsKind(STANDARD_TYPE(%Schema))) {
$          _anOtherObject = Handle(%Schema)((Handle(%Schema)&)AnObject);
$        }
$     }
$
$     return _anOtherObject ;
$   }
$};
$
$#ifndef _Storage_CallBack_HeaderFile_
$#include <Storage_CallBack.hxx>
$#endif
$#ifndef _Storage_BaseDriver_HeaderFile_
$#include <Storage_BaseDriver.hxx>
$#endif
$
$class %Schema : public Storage_Schema {
$public:
$
$  Storage_DECLARE_SCHEMA_METHODS(%Schema)
$
$  Standard_Boolean IsKind(const Handle(Standard_Type)& AType) const 
$  { 
$    return (STANDARD_TYPE(%Schema) == AType || Storage_Schema::IsKind(AType)); 
$  }
$
$  const Handle(Standard_Type)& DynamicType() const 
$  { 
$    return STANDARD_TYPE(%Schema) ; 
$  }
$};
$
$#endif
@end;

@template CSFDBPCallBackClass(%Schema,%Type,%Include) is
$// File generated by Schema (CallBack)
$//
$//                     Copyright (C) 1991 - 2000 by  
$//                      Matra Datavision SA.  All rights reserved.
$//  
$// This file is part of the Open CASCADE Technology software.
$//
$// This software may be distributed and/or modified under the terms and
$// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
$// and appearing in the file LICENSE included in the packaging of this file.
$//  
$// This software is distributed on an "AS IS" basis, without warranty of any
$// kind, and Open CASCADE SA hereby disclaims all such warranties,
$// including without limitation, any warranties of merchantability, fitness
$// for a particular purpose or non-infringement. Please see the License for
$// the specific terms and conditions governing rights and limitations under the
$// License.
$
$#ifndef _%Schema_%Type_HeaderFile
$#define _%Schema_%Type_HeaderFile
$
$#ifndef _Storage_Schema_HeaderFile
$#include <Storage_Schema.hxx>
$#endif
$#ifndef _Storage_CallBack_HeaderFile_
$#include <Storage_CallBack.hxx>
$#endif
$#ifndef _Storage_BaseDriver_HeaderFile_
$#include <Storage_BaseDriver.hxx>
$#endif
$
$%Include
$
$class Handle_%Type;
$
$class Handle_Standard_Type;
$Standard_EXPORT Handle_Standard_Type& %Schema_%Type_Type_();
$Standard_EXPORT Handle_Standard_Type& %Type_Type_();
$class Standard_Transient;
$class Handle_Standard_Persistent;
$class %Schema_%Type;
$
$class Handle(%Schema_%Type) : public Handle(Storage_CallBack) {
$  public:
$    Handle(%Schema_%Type)() : Handle(Storage_CallBack)() {} 
$    Handle(%Schema_%Type)(const Handle(%Schema_%Type)& aHandle) : Handle(Storage_CallBack)(aHandle) 
$     {
$     }
$
$    Handle(%Schema_%Type)(const %Schema_%Type* anItem) : Handle(Storage_CallBack)((Storage_CallBack *)anItem) 
$     {
$     }
$
$    Handle(%Schema_%Type)& operator=(const Handle(%Schema_%Type)& aHandle)
$     {
$      Assign(aHandle.Access());
$      return *this;
$     }
$
$    Handle(%Schema_%Type)& operator=(const %Schema_%Type* anItem)
$     {
$      Assign((Standard_Transient *)anItem);
$      return *this;
$     }
$
$    %Schema_%Type* operator->() 
$     {
$      return (%Schema_%Type *)ControlAccess();
$     }
$
$    %Schema_%Type* operator->() const 
$     {
$      return (%Schema_%Type *)ControlAccess();
$     }
$
$   ~Handle(%Schema_%Type)(){};
$
$   Standard_EXPORT static const Handle(%Schema_%Type) DownCast(const Handle(Storage_CallBack)&);
$};
$
$
$class %Schema_%Type : public Storage_CallBack {
$  public:
$   %Schema_%Type() {};
$   Standard_EXPORT static void SAdd(const Handle(%Type)& ,const Handle(Storage_Schema)&);
$   Standard_EXPORT static void SWrite(const Handle(Standard_Persistent)&,Storage_BaseDriver&,const Handle(Storage_Schema)&);
$   Standard_EXPORT static void SRead(const Handle(Standard_Persistent)&,Storage_BaseDriver&,const Handle(Storage_Schema)&);
$
$   Standard_EXPORT Handle_Standard_Persistent New() const;
$   Standard_EXPORT void Add(const Handle(Standard_Persistent)&,const Handle(Storage_Schema)&) const;
$   Standard_EXPORT void Write(const Handle(Standard_Persistent)&,Storage_BaseDriver&,const Handle(Storage_Schema)&) const;
$   Standard_EXPORT void Read(const Handle(Standard_Persistent)&,Storage_BaseDriver&,const Handle(Storage_Schema)&) const;
$   ~%Schema_%Type() {};
$
$   Standard_EXPORT Standard_Boolean IsKind(const Handle(Standard_Type)& AType) const; 
$   Standard_EXPORT const Handle(Standard_Type)& DynamicType() const;
$};
$#endif
@end;

@template CSFDBSCallBackClass(%Schema,%Type,%Include) is
$// File generated by Schema (Storable CallBack)
$//
$//                     Copyright (C) 1991 - 2000 by  
$//                      Matra Datavision SA.  All rights reserved.
$//  
$// This file is part of the Open CASCADE Technology software.
$//
$// This software may be distributed and/or modified under the terms and
$// conditions of the Open CASCADE Public License as defined by Open CASCADE SA
$// and appearing in the file LICENSE included in the packaging of this file.
$//  
$// This software is distributed on an "AS IS" basis, without warranty of any
$// kind, and Open CASCADE SA hereby disclaims all such warranties,
$// including without limitation, any warranties of merchantability, fitness
$// for a particular purpose or non-infringement. Please see the License for
$// the specific terms and conditions governing rights and limitations under the
$// License.
$
$#ifndef _%Schema_%Type_HeaderFile
$#define _%Schema_%Type_HeaderFile
$
$#ifndef _Handle_Storage_Schema_HeaderFile
$#include <Handle_Storage_Schema.hxx>
$#endif
$#ifndef _Storage_BaseDriver_HeaderFile_
$#include <Storage_BaseDriver.hxx>
$#endif
$
$%Include
$
$class %Type;
$
$class %Schema_%Type {
$  public:
$   Standard_EXPORT static void SAdd(const %Type&,const Handle(Storage_Schema)& aSchema);
$   Standard_EXPORT static void SWrite(const %Type&,Storage_BaseDriver& aDriver,const Handle(Storage_Schema)& aSchema);
$   Standard_EXPORT static void SRead(%Type&,Storage_BaseDriver& aDriver,const Handle(Storage_Schema)& aSchema);
$};
$
$#endif
@end;

-- -------------- AddTypeSelection
--
@template CSFDBADDTSBegin(%Schema,%Type) is
$
$ Storage_BEGIN_ADD_TYPES(%Schema)
@end;

@template CSFDBADDTSPart(%Schema,%Type) is
$ Storage_ADD_TYPES(%Schema,%Type,%Schema_%Type)
@end;

@template CSFDBADDTSEnd(%Schema) is
$ Storage_END_ADD_TYPES(%Schema)
$
@end;
--
-- -------------- AddTypeSelection

-- -------------- TypeList
--
@template CSFDBTypeListBegin(%Schema) is
$
$  Storage_BEGIN_SCHEMA_TYPES(%Schema)
@end;

@template CSFDBTypeListPart(%Type) is
$  Storage_SCHEMA_TYPES(%Type)
@end;

@template CSFDBTypeListEnd(%Schema) is
$  Storage_END_SCHEMA_TYPES(%Schema)
$
@end;
--
-- -------------- TypeList

-- -------------- ReadTypeSelection
--
@template CSFDBREADTSBegin(%Schema) is
$
$ Storage_BEGIN_READ_SELECTION(%Schema)
@end;

@template CSFDBREADTSPart(%Schema,%Type) is
$ Storage_READ_SELECTION(%Schema,%Type,%Schema_%Type)
@end;

@template CSFDBREADTSEnd(%Schema) is
$ Storage_END_READ_SELECTION(%Schema)
$
@end;
--
-- -------------- ReadTypeSelection

-- -------------- ADD
--
@template CSFDBSADD(%Schema,%Type,%Body) is
$
$void %Schema_%Type::SAdd(const %Type& p, const Handle(Storage_Schema)& theSchema)
${
$  %Body
$}
@end;

@template CSFDBPADD(%Schema,%Type,%Body) is
$
$void %Schema_%Type::SAdd(const Handle(%Type)& p, const Handle(Storage_Schema)& theSchema)
${
$  if (!p.IsNull()) {
$    if (theSchema->AddPersistent(p,"%Type")) {
$      %Body
$    }
$  }
$}
$
$void %Schema_%Type::Add(const Handle(Standard_Persistent)& p, const Handle(Storage_Schema)& theSchema) const {
$  %Schema_%Type::SAdd((Handle(%Type)&)p,theSchema);
$}
@end;
--
-- -------------- ADD

-- -------------- WRITE
--
@template CSFDBSWRITE(%Schema,%Type,%Body) is
$
$void %Schema_%Type::SWrite(const %Type& pp, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${
$  f.BeginWriteObjectData();
$%Body
$  f.EndWriteObjectData();
$}
@end;


@template CSFDBPWRITE(%Schema,%Type,%Body) is
$
$void %Schema_%Type::SWrite(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${ 
$  if (!p.IsNull()) {
$    Handle(%Type) &pp = (Handle(%Type)&)p;
$    theSchema->WritePersistentObjectHeader(p,f);
$    
$    f.BeginWritePersistentObjectData();
$%Body
$    f.EndWritePersistentObjectData();
$  }
$}
$
$void %Schema_%Type::Write(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema) const
${ 
$ %Schema_%Type::SWrite(p,f,theSchema);
$}
@end;
--
-- -------------- WRITE

-- -------------- READ
--
@template CSFDBNEWOBJECT(%Schema,%Type) is
$Handle(Standard_Persistent) %Schema_%Type::New() const
${
$ return new %Type(Storage_stCONSTclCOM());
$}
@end;

@template CSFDBNEWOBJECTDeferred(%Schema,%Type) is
$Handle(Standard_Persistent) %Schema_%Type::New() const
${
$ Handle(Standard_Persistent) NullObject;
$ return NullObject;
$}
@end;

@template CSFDBSREAD(%Schema,%Type,%Body) is
$void %Schema_%Type::SRead(%Type& pp, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${
$  f.BeginReadObjectData();
$%Body
$  f.EndReadObjectData();
$}
@end;

@template CSFDBPREAD(%Schema,%Type,%Body) is
$void %Schema_%Type::SRead(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${ 
$  if (!p.IsNull()) {
$    Handle(%Type) &pp = (Handle(%Type)&)p;
$
$    theSchema->ReadPersistentObjectHeader(f);
$    f.BeginReadPersistentObjectData();
$
$%Body
$    f.EndReadPersistentObjectData();
$  }
$}
$
$void %Schema_%Type::Read(const Handle(Standard_Persistent)& p, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema) const
${ 
$ %Schema_%Type::SRead(p,f,theSchema);
$}
@end;

@template CSFDBPparameter(%Type,%Field,%NameField,%TCall) is
$
$    Handle(%Type) %NameField%Field;
$
$    theSchema->ReadPersistentReference(%NameField%Field,f);
$    pp%TCall_CSFDB_Set%NameField%Field(%NameField%Field);
@end;

@template CSFDBSparameter(%Schema,%Type,%Field,%NameField,%TCall) is
$
$    %Schema_%Type::SRead((%Type&)pp%TCall_CSFDB_Get%NameField%Field(),f,theSchema);
@end;

@template CSFDBprimitive(%FType,%Field,%NameField,%Convert,%TCall) is
$
$    %FType %NameField%Field;
$    %Convert(%NameField%Field);
$    pp%TCall_CSFDB_Set%NameField%Field(%NameField%Field);
@end;

@template CSFDBenumeration(%FType,%Field,%NameField,%Convert,%TCall) is
$
$    %FType %NameField%Field;
$    Standard_Integer i_CSFDB_%NameField%Field;
$    %Convert(i_CSFDB_%NameField%Field);
$    %NameField%Field = (%FType)i_CSFDB_%NameField%Field;
$    pp%TCall_CSFDB_Set%NameField%Field(%NameField%Field);
@end;

@template CSFDBREADfloat() is
$f.GetReal\^
@end;

@template CSFDBREADint() is
$f.GetInteger\^
@end;

@template CSFDBREADenum(%Type) is
$f.GetInteger\^
@end;

@template CSFDBREADchar() is
$f.GetCharacter\^
@end;

@template CSFDBREADshortreal() is
$f.GetShortReal\^
@end;

@template CSFDBREADextchar() is
$f.GetExtCharacter\^
@end;

@template CSFDBREADboolean() is
$f.GetBoolean\^
@end;


--
-- -------------- READ

-- -------------- DBC
--
@template CSFDBSADDDBC(%Schema,%Type) is
$  Standard_Integer i;
$  for (i = 0; i < p.Length(); i++) {
$    %Schema_%Type::SAdd(p.Value(i),theSchema);    
$  }
@end;

@template CSFDBPADDDBC(%Schema) is
$  Standard_Integer i;
$  for (i = 0; i < p.Length(); i++) {
$    theSchema->PersistentToAdd(p.Value(i));    
$  }
@end;

@template CSFDBWRITEDBC(%Schema,%Type,%Body) is
$void %Schema_%Type::SWrite(const %Type& pp, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${
$  Standard_Integer i;
$
$  f.BeginWriteObjectData();
$  f.PutInteger(pp.Length());
$  for (i = 0; i < pp.Length(); i++) {
$%Body
$  }
$  f.EndWriteObjectData();
$}
@end;

@template CSFDBREADDBC(%Schema,%Type,%Body) is
$void %Schema_%Type::SRead(%Type& pp, Storage_BaseDriver& f, const Handle(Storage_Schema)& theSchema)
${
$  Standard_Integer size = 0;
$
$  f.BeginReadObjectData();
$  f.GetInteger(size);
$  pp.Resize(size);
$
$  for (Standard_Integer j = 0; j < size; j++) {
$%Body
$  }
$  f.EndReadObjectData();
$}
@end;

@template CSFDBCallWRITE(%Schema,%Type,%Field,%NameField,%TCall) is
$    %Schema_%Type::SWrite(pp%TCall_CSFDB_Get%NameField%Field(),f,theSchema);
@end;

@template CSFDBDBCRfloat() is
$    Standard_Real par;
$
$    f.GetReal(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRint() is
$    Standard_Integer par;
$
$    f.GetInteger(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRenum(%Type) is
$    %Type par;
$    Standard_Integer parcv = 0;
$
$    f.GetInteger(parcv);
$    par = (%Type)parcv;
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRchar() is
$    Standard_Character par;
$
$    f.GetCharacter(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRextchar() is
$    Standard_ExtCharacter par;
$
$    f.GetExtCharacter(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRshortreal() is
$    Standard_ShortReal par;
$
$    f.GetShortReal(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCRboolean() is
$    Standard_Boolean par;
$
$    f.GetBoolean(par);
$    pp.SetValue(j,par);
@end;

@template CSFDBDBCPparameter(%Type,%Field,%TCall) is
$    Handle(%Type) par;
$
$    theSchema->ReadPersistentReference(par,f);
$    pp.SetValue(j,par);
@end;


@template CSFDBDBCSparameter(%Schema,%Type) is
$    %Schema_%Type::SRead((%Type&)pp.Value(j),f,theSchema);
@end;

@template CSFDBDBCWprim(%DriverFunction) is
$    f.%DriverFunction(pp.Value(i));
@end;

@template CSFDBDBCWpersistent() is
$    theSchema->WritePersistentReference(pp.Value(i),f);
@end;

@template CSFDBDBCWstorable(%Schema,%Type) is
$    %Schema_%Type::SWrite(pp.Value(i),f,theSchema);
@end;
--
-- -------------- DBC

-- ------------- General
--
@template CSFDBCallAddTypeSelection(%Schema,%Field,%NameField,%TCall) is
$   theSchema->PersistentToAdd(p%TCall_CSFDB_Get%NameField%Field());
@end;

@template CSFDBCallAdd(%Schema,%Type,%Field,%NameField,%TCall) is
$   %Schema_%Type::SAdd(p%TCall_CSFDB_Get%NameField%Field(),theSchema);
@end;

@template CSFDBCallWritePersistent(%Field,%NameField,%TCall) is
$  theSchema->WritePersistentReference(pp%TCall_CSFDB_Get%NameField%Field(),f);
@end;

@template CSFDBComma() is
$\^
@end;

@template CSFDBCallWritePrimitive(%Field,%NameField,%TCall,%DriverFunction) is
$  f.%DriverFunction(pp%TCall_CSFDB_Get%NameField%Field());
@end;

@template CSFDBInclude(%Type) is
$#ifndef _%Type_HeaderFile_
$#include <%Type.hxx>
$#endif
@end;

@template CSFDBDerivatedInclude(%Schema,%Type) is
$#ifndef _%Schema_%Type_HeaderFile_
$#include <%Schema_%Type.hxx>
$#endif
@end;

@template CSFDBIxxInclude(%Schema,%Type) is
$#include <%Schema_%Type.ixx>
@end;

--
-- ------------- General

-- ------------- C++ Array
--
@template CSFDBCallAddTypeSelectionArray(%Schema,%Field,%NameField,%TCall,%VDim) is
$   theSchema->PersistentToAdd(p%TCall_CSFDB_Get%NameField%Field(%VDim));
@end;

@template CSFDBCallAddArray(%Schema,%Type,%Field,%NameField,%TCall,%VDim) is
$   %Schema_%Type::SAdd(p%TCall_CSFDB_Get%NameField%Field(%VDim),theSchema);
@end;

@template CSFDBforWrite(%Var,%Length) is
$    for (%Var = 0; %Var < %Length; %Var++)
@end;

@template CSFDBforRead(%Var,%Length) is
$    for (%Var = 0; %Var < %Length; %Var++)
@end;

@template CSFDBCallWritePrimitiveArray(%Field,%NameField,%TCall,%VDim,%Cast,%DriverFunction) is
$    f.%DriverFunction((%Castpp)%TCall_CSFDB_Get%NameField%Field(%VDim));
@end;

@template CSFDBCallWritePersistentArray(%Field,%NameField,%TCall,%VDim,%Cast) is
$    theSchema->WritePersistentReference((%Castpp)%TCall_CSFDB_Get%NameField%Field(%VDim),f);
@end;

@template CSFDBCallWriteStorableArray(%Schema,%Type,%Field,%NameField,%TCall,%VDim,%Cast) is
$    %Schema_%Type::SWrite((%Castpp)%TCall_CSFDB_Get%NameField%Field(%VDim),f,theSchema);
@end;

@template CSFDBWRITEARRAYcpp(%Schema,%Type,%LocalVar,%ForW,%Body) is
$  Standard_Integer %LocalVar;
$
$%ForW {
$%Body
$  }
@end;

@template CSFDBReadPrimitiveArray(%Type,%Field,%NameField,%Convert,%TCall,%VDim) is
$  %Type %NameField%Field;
$
$  %Convert(%NameField%Field);
$  pp%TCall_CSFDB_Get%NameField%Field(%VDim) = %NameField%Field;
@end;

@template CSFDBReadEnumArray(%Type,%Field,%NameField,%Convert,%TCall,%VDim) is
$  %Type %NameField%Field;
$  Standard_Integer i_CSFDB_%NameField%Field;
$
$  %Convert(i_CSFDB_%NameField%Field);
$  %NameField%Field = (%Type)i_CSFDB_%NameField%Field;
$  pp%TCall_CSFDB_Get%NameField%Field(%VDim) = %NameField%Field;
@end;

@template CSFDBReadPersistentArray(%Type,%Field,%NameField,%TCall,%VDim) is
$    Handle(%Type) %NameField%Field;
$
$    theSchema->ReadPersistentReference(%NameField%Field,f);
$    pp%TCall_CSFDB_Get%NameField%Field(%VDim) = %NameField%Field;
@end;

@template CSFDBReadStorableArray(%Schema,%Type,%Field,%NameField,%TCall,%VDim) is
$    %Schema_%Type::SRead((%Type&)pp%TCall_CSFDB_Get%NameField%Field(%VDim),f,theSchema);
@end;

@template CSFDBREADARRAYcpp(%Schema,%Type,%LocalVar,%ForR,%Body) is
$  Standard_Integer %LocalVar;
$   
$%ForR {
$%Body
$}
@end;
--
-- ------------- C++ Array
@template CSFDBTypeMgt(%Schema) is
$
$Handle_Standard_Type& %Schema_Type_()
${
$
$  static Handle_Standard_Type tSchema = STANDARD_TYPE(%Schema); 
$  static Handle_Standard_Type bSchema = STANDARD_TYPE(Storage_Schema);
$
$  static Handle_Standard_Transient _Ancestors[]= {tSchema,bSchema,NULL};
$  static Handle_Standard_Type _aType = new Standard_Type("%Schema",
$			                                 sizeof(%Schema),
$			                                 1,
$			                                 (Standard_Address)_Ancestors,
$			                                 (Standard_Address)NULL);
$
$  return _aType;
$}
$
@end;

@template CSFDBCallBackTypeMgt(%Schema,%Type) is
$
$Handle_Standard_Type& %Schema_%Type_Type_()
${
$
$  static Handle_Standard_Type tSchema = STANDARD_TYPE(%Schema_%Type); 
$  static Handle_Standard_Type bSchema = STANDARD_TYPE(Storage_CallBack);
$
$  static Handle_Standard_Transient _Ancestors[]= {tSchema,bSchema,NULL};
$  static Handle_Standard_Type _aType = new Standard_Type("%Schema_%Type",
$			                                 sizeof(%Schema_%Type),
$			                                 1,
$			                                 (Standard_Address)_Ancestors,
$			                                 (Standard_Address)NULL);
$
$  return _aType;
$}
$
$const Handle(%Schema_%Type) Handle(%Schema_%Type)::DownCast(const Handle(Storage_CallBack)& AnObject) {
$  Handle(%Schema_%Type) _anOtherObject;
$
$  if (!AnObject.IsNull()) {
$     if (AnObject->IsKind(STANDARD_TYPE(%Schema_%Type))) {
$       _anOtherObject = Handle(%Schema_%Type)((Handle(%Schema_%Type)&)AnObject);
$     }
$  }
$
$  return _anOtherObject ;
$}
$
$Standard_Boolean %Schema_%Type::IsKind(const Handle(Standard_Type)& AType) const { 
$  return (STANDARD_TYPE(%Schema_%Type) == AType || Storage_CallBack::IsKind(AType)); 
$}
$
$const Handle(Standard_Type)& %Schema_%Type::DynamicType() const { 
$  return STANDARD_TYPE(%Schema_%Type) ; 
$}
@end;

@template CSFDBClassDeclaration (%Type) is
$class %Type;
@end;

@template CSFDBHandleDeclaration (%Type) is
$class Handle_%Type;
@end;
